@database extrdargs.doc
@master extrdargs.doc
@node main "extrdargs.doc"
@toc xref.library_xreffile@main
@{settabs 40}@{" --background-- " link "--background--"}	@{" ExtFreeArgs() " link "ExtFreeArgs()"}
@{" ExtReadArgs() " link "ExtReadArgs()"}

@endnode
@node "--background--" "ExtReadArgs/--background--"

    @{b}PURPOSE@{ub}
        This is a CLI/Workbench transparent argument interface. I don't liked
        the way of parsing ToolTypes and used only the @{"ReadArgs()" link "dos/ReadArgs()"} function.
        Thus all my tools can only be invoked from the CLI/Shell . Thats the
        reason for building this project !

    @{b}FUNCTION@{ub}
        @{"ExtReadArgs()" link "ExtReadArgs()"} copies all Workbench arguments in a single string and
        passes this string to the @{"ReadArgs()" link "dos/ReadArgs()"} function. All @{"WBArg" link "AG:SysInc/workbench/startup.h/main" 34} structure
        are expanded to their full filenames , enclosed in '"' and passed to
        the item specified via the erda_FileParameter field. Then all Tool-
        types are strcat()'ed into one line, thus @{"ReadArgs()" link "dos/ReadArgs()"} can handle it.
        To handle each Tooltype correctly the argument is enclosed in '"' !

    @{b}NOTE@{ub}
        There are some special feature according to the @{"ReadArgs()" link "dos/ReadArgs()"} function.
        If you have a template like "FROM/M/A,TO/A", you can select these
        files from workbench : Select the program, then the FROM files and
        finally select and double click th TO file. This is available,because
        @{"ReadArgs()" link "dos/ReadArgs()"} grab's the last string from a MultiArg FROM and uses it
        as the TO parameter, if no is explicitly given !

    @{b}INSPIRATION@{ub}
        I get the main idea, how I implement the Workbench @{"ReadArgs()" link "dos/ReadArgs()"}
        interface from the author of ARoach Stefan Winterstein. Thanks for
        this idea of parsing ToolTypes !


@endnode
@node "ExtFreeArgs()" "ExtReadArgs/ExtFreeArgs()"

    @{b}NAME@{ub}
        ExtFreeArgs - free's all allocated resources from @{"ExtReadArgs()" link "ExtReadArgs()"}

    @{b}SYNOPSIS@{ub}
        ExtFreeArgs(extrdargs);

        void ExtFreeArgs(struct @{"ExtRDArgs" link "extrdargs.h/main" 34} *);

    @{b}FUNCTION@{ub}
        free's all allocated resources from a previously call to
        @{"ExtReadArgs()" link "ExtReadArgs()"}.

    @{b}INPUTS@{ub}
        extrdargs (struct @{"ExtRDArgs" link "extrdargs.h/main" 34} *) - same pointer, which was passed
            to @{"ExtReadArgs()" link "ExtReadArgs()"}

    @{b}RESULTS@{ub}
        none

    @{b}SEE ALSO@{ub}
        @{"ExtReadArgs()" link "ExtReadArgs()"}


@endnode
@node "ExtReadArgs()" "ExtReadArgs/ExtReadArgs()"

    @{b}NAME@{ub}
        ExtReadArgs - CLI/Workbench transparent @{"ReadArgs()" link "dos/ReadArgs()"} function

    @{b}SYNOPSIS@{ub}
        error = ExtReadArgs(ac,av,extrdargs);

        @{"LONG" link "AG:SysInc/exec/types.h/main" 36} ExtReadArgs(@{"LONG" link "AG:SysInc/exec/types.h/main" 36} ,@{"STRPTR" link "AG:SysInc/exec/types.h/main" 52} *,struct @{"ExtRDArgs" link "extrdargs.h/main" 34} *);

    @{b}FUNCTION@{ub}
        this function is a CLI/Workbench transparent interface to @{"ReadArgs()" link "dos/ReadArgs()"}.
        It uses the argcount and argvector like SASC from the main entry
        point, to get the initial startup parameter. If ac is zero, so the
        program is invoked from workbench and the av variable contains the
        @{"WBStartup" link "AG:SysInc/workbench/startup.h/main" 25} structure ! Before you can call this function, you must set
        up the library bases for dos.library and icon.library. Normally the
        SASC autoinitialization code does this for you !
        If all went right you get a return value of zero. This means the
        passed arguments fits the template and are ready to use. Otherwise
        you get a @{"IoErr()" link "dos/IoErr()"} like return code. You can pass this return value
        directly to @{"PrintFault()" link "dos/PrintFault()"} or something like that !

        NOTE : You must call the @{"ExtFreeArgs()" link "ExtFreeArgs()"} function to clean up, even
               this function fails (see EXAMPLE) !!!

    @{b}INPUTS@{ub}
        ac (@{"LONG" link "AG:SysInc/exec/types.h/main" 36}) - parameter normally get from main()
        av (@{"STRPTR" link "AG:SysInc/exec/types.h/main" 52} *) - parameter normally get from main()
        extrdargs (struct @{"ExtRDArgs" link "extrdargs.h/main" 34} *) - structure , which hold any
            information used by ExtReadArgs()

        structure fields to setup before calling ExtReadArgs() :

            erda_Template - the really @{"ReadArgs()" link "dos/ReadArgs()"} template
            erda_Parameter - @{"ReadArgs()" link "dos/ReadArgs()"} @{"LONG" link "AG:SysInc/exec/types.h/main" 36} @{"WORD" link "AG:SysInc/exec/types.h/main" 39} array to hold the arguments
            erda_FileParameter - number of Argument in the template to use
                for the files passed via WBStartup->sm_ArgList or -1, that
                means you don't want any files
            erda_Window - window description string to open, if the program
                is started from the workbench or @{"NULL" link "AG:SysInc/exec/types.h/main" 79} for no window ! If
                in the ToolType Array exists a WINDOW description this is
                used
                instead of the parameter of the @{"ExtRDArgs" link "extrdargs.h/main" 34} structure !
            erda_RDArgs - @{"RDArgs" link "AG:SysInc/dos/rdargs.h/main" 95} structure to use for @{"ReadArgs()" link "dos/ReadArgs()"} call, thus
                you can use extended help !
            erda_Buffer - pointer to a buffer to use for the Workbench
            startup
                or @{"NULL" link "AG:SysInc/exec/types.h/main" 79}, that means ExtReadArgs() allocates a buffer for you
            erda_BufferSize - if you provided a buffer, here is the length of
                it. If not this is the length you would have ! This length is
                checked against a minimum of @{"ERDA_MIN_BUFFER_SIZE" link "extrdargs.h/main" 71} !

    @{b}RESULTS@{ub}
        zero for success, otherwise an @{"IoErr()" link "dos/IoErr()"} like error code.

        If the function successes you can check the erda_Flags field for the
        FRDAF_WORKBENCH flag, if you want to known from where the program was
        started

    @{b}EXAMPLE@{ub}
        /* In this example the dos.library and icon.library must be open
         * from autoinitialization code
         */
        @{"LONG" link "AG:SysInc/exec/types.h/main" 36} main(@{"LONG" link "AG:SysInc/exec/types.h/main" 36} ac,@{"STRPTR" link "AG:SysInc/exec/types.h/main" 52} *av)
        {
           struct @{"ExtRDArgs" link "extrdargs.h/main" 34} eargs = {@{"NULL" link "AG:SysInc/exec/types.h/main" 79}};
           @{"LONG" link "AG:SysInc/exec/types.h/main" 36} para[2];
           @{"LONG" link "AG:SysInc/exec/types.h/main" 36} error;

           eargs.erda_Template      = "FILES/M/A,VERBOSE";
           eargs.erda_Parameter     = para;
           eargs.erda_FileParameter = 0;
           eargs.erda_Window        = "CON:////My WB-Window/CLOSE/WAIT";

           if((error = ExtReadArgs(ac,av,&eargs)) == 0)
           {
              /* do something */
           } else
              @{"PrintFault" link "dos/PrintFault()"}(error,"MyProgram");
           @{"ExtFreeArgs" link "ExtFreeArgs()"}(&eargs);

           return((error == 0) ? @{"RETURN_OK" link "AG:SysInc/dos/dos.h/main" 232} : @{"RETURN_FAIL" link "AG:SysInc/dos/dos.h/main" 235});
        }

    @{b}SEE ALSO@{ub}
        @{"ExtFreeArgs()" link "ExtFreeArgs()"}, @{"dos.library/ReadArgs()" link "dos/ReadArgs()"},
        @{"icon.library/GetDiskObjectNew()" link "icon/GetDiskObjectNew()"}


@endnode
